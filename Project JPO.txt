- Libraries
	import java.sql.Connection;
	import java.sql.DriverManager;
	import java.sql.SQLException;
	import java.sql.ResultSet;
	import java.sql.Statement;
	import java.util.Iterator;
	import java.util.*;
	import java.io.*;
	import java.lang.reflect.Parameter;
	import java.lang.reflect.Member;
	import java.lang.reflect.Executable;
	import java.lang.reflect.Method;
	import java.lang.reflect.Constructor;

	import matrix.util.StringList;

	import com.matrixone.apps.domain.util.MqlUtil;
	import com.matrixone.apps.domain.util.FrameworkUtil;
	import matrix.db.*;

	import java.io.File;
	import java.io.FileWriter;
	import java.io.IOException;

- sql query --> create table with columns
	String sql1 = "CREATE TABLE JPO_Info " + "(\"JPO Name\" VARCHAR(max), "
		+ " \"Function name\" VARCHAR(max), " + " \"Function arg\" VARCHAR(max), "
		+ " \"Function return type\" VARCHAR(max)," + " Extends VARCHAR(max))";
	stmt.executeUpdate(sql1);
	
- to check JPO contains code or not? Then only extract further data otherwise move to next JPO
	if (code.isBlank()) {
		continue;
	}
	
- make class object
	Class classobj = Class.forName(progClassName);
	
- get extend class with its simple name
	classobj.getSuperclass().getSimpleName().split("mxJPO")[0] + "mxJPO";
	
	*split portion splits the simple name with "mxJPO" and adds mxJPO in the left side of splitted portion
	
- to check string contains the given substring?
	classobj.getSuperclass().getSimpleName().contains("mxJPO")
	
- to check string matches with other string
	nameExtends.equals("Object")
	
- get declared constructors
	Constructor[] allDeclConst = classobj.getDeclaredConstructors();

- iterate the constructors and get the parameters, 
	for (Constructor constructor : allDeclConst) {
		Parameter[] constType = constructor.getParameters();
		
	--> get the constructor name
			System.out.println("\nConstructor Name : " + constructor.getName());
			nameFunc = constructor.getName();
			System.out.println("No of Constructor Parameters : " + constType.length);

	--> get the combined types name and arguments name
			System.out.println("Constructor object details:");
			ArrayList<String> argumentList = new ArrayList<String>();
			for (Parameter classobject : constType) {
				// System.out.println(classobject.getName());
				argumentList.add(classobject.getType().getSimpleName() + " " + classobject.getName());
			}
			
	--> check constructor has at least one argument to avoid unnecessary constructor creation		
	System.out.println(argumentList);
	if (argumentList.isEmpty()) {
		continue;
	}

sql query --> insert into table (program name, function name, arguments, return type, extends for constructor
	String sql2 = "INSERT INTO JPO_Info" + " VALUES ('" + program + "','"
			+ nameFunc.split("mxJPO")[0] + "mxJPO" + "','" + argumentList + "','" + nameReturnType
			+ "','" + nameExtends + "')";

	stmt.executeUpdate(sql2);
	}
	
- to avoid "Object" in extends columns
		if (classobj.getSuperclass().getSimpleName().contains("mxJPO")) {
				nameExtends = classobj.getSuperclass().getSimpleName().split("mxJPO")[0] + "mxJPO";
		} else {
			nameExtends = classobj.getSuperclass().getSimpleName();
			
			System.out.println(nameExtends);
			if (nameExtends.equals("Object")) {
				nameExtends = "";
		
- get declared methods
	Method[] methods = classobj.getDeclaredMethods();
	
- iterate methods and get the parameters
		for (Method method : methods) {

			Parameter[] parameters = method.getParameters();
	--> get return type as class object 
			// Apply getReturnType() method
			Class returnParam = method.getReturnType();

	--> get method name
			nameFunc = method.getName();
	
	--> avoid unnecessary methods from class function
			if ((nameFunc == "notifyAll") || (nameFunc == "notify") || (nameFunc == "toString")
					|| (nameFunc == "equals") || (nameFunc == "hashCode") || (nameFunc == "wait")
					|| (nameFunc == "getClass")) {
				continue;
			}
	--> get return type name
			nameReturnType = returnParam.getSimpleName();

	--> get the combined types name and  arguments name
			System.out.println("Parameter object details:");
			ArrayList<String> argumentList = new ArrayList<String>();
			for (Parameter classobject : parameters) {
				// System.out.println(classobject.getName());
				argumentList.add(classobject.getType().getSimpleName() + " " + classobject.getName());
			}
			System.out.println(argumentList);

	--> insert into table (program name, function name, arguments, return type, extends for method
			String sql2 = "INSERT INTO JPO_Info" + " VALUES ('" + program + "','" + nameFunc + "','"
					+ argumentList + "','" + nameReturnType + "','" + nameExtends + "')";

			stmt.executeUpdate(sql2);
		}
		
- why exception handling used (try catch blocks)
	1. // Handle errors for JDBC
	2. // Handle errors for Class.forName
	3. // Handle errors for class object
		*One error will not stop total execution of code